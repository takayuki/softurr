SoftURR -- a preliminary software implementation of URR
URRのソフトウェアによる実装の試み
README

目次
 1. SoftURRとは
 2. URR(Universal Representation of Real numbers)とは
 3. 著作権
 4. 使用条件
 5. コンパイル
 6. インストール
 7. デモンストレーション
 8. リンク
 9. 謝辞
10. 連絡先


1. SoftURRとは

SoftURRは、URR(Universal Representation of Real numbers;万能数値表現法)の
ソフトウェアによる実装です。

URRは、算術的に美しく、実用的にも優れた浮動小数点数の表現方法ですが、
ハードウェアで実現することが容易でなかったため、
IEEE 754のように広く用いられることはありませんでした。

SoftURRでは、"動く"URRをソフトウェア(x86の整数演算)で実装してみることで、
URRを実用化するときに必要となってくる知識や経験を蓄積し、
最終的には、(夢は大きく！)規格化に向けた提言を行うことを目標としています。


2. URR(Universal Representation of Real numbers)とは

非常に残念なことに、URRの知名度はとても低いといわざるを得ません。
わたしの知る限り、まとまった解説を読めるはつぎのサイトだけです。

万能数値表現法　ＵＲＲ
http://homepage2.nifty.com/m_kamada/docsproc/asmurr.htm

わたしも、ここで読んだ情報だけでSoftURRを書きました。

このほかにも、URRについて参照できるもの(原論文も含めて)をご存じの方は、
ぜひご一報ください。よろしくお願いします。

そのような状況なので、ここであらためてURRの特徴を書き出したとしても、
上記のサイトの繰り返しになってしまう可能性が高いです。
ぜひうえの記事をご覧になって、URRの美しさを堪能してください。

いずれ、SoftURRで得られた経験を生かしながら、
わたしなりの解説を書いてみようと思っています。

いまの時点で、ひとつだけ補足しておくとすれば、
つぎのようなことでしょうか。

----
URRをデータ圧縮という観点からとらえることもできます。
指数部をワイル符号(*)に似た方法で圧縮しているのです。

IEEE 754が、どんなに小さな指数にも(たとえ0であっても)、
固定長のビット列をぜんぶ使ってしてしまうのとまったく対照的です

指数部を圧縮して残りのビットをすべて仮数部に割り当てます。
そのため、指数部も仮数部も可変長という表現方法が可能になったわけです。

(*)ワイル符号は小さな整数を圧縮する手段のひとつです。
   画像圧縮などは、ほかのスキームと組み合わせてよく用いられます。
----

3. 著作権

SoftURRは、臼井崇行が著作権を保持しています。


4. 使用条件

SoftURRは、Free Software FoundationのGNU General Public Licensenのもとで
公開されています。GPLに従う限り自由に再配布・改変することができます。
詳しくは、この配布物に含まれているCOPYINGというファイルを参照してください。

現時点では、LGPL(The GNU Lesser General Public License)は適用されません。
ただし、今後も開発が継続され、数値計算ライブラリとして、
有用であると判断された場合には、LGPLへ移行することも検討します。


5. コンパイル

SoftURRをコンパイルするには、つぎのソフトウェアが必要です。

 (1) The Netwide Assembler
     http://sourceforge.net/projects/nasm/

     古いものは(新しいものも!?)いくつかバグがあるので、
     最新版(0.98.39)がよいようです。

 (2) GCC & make

     g++が必要です。わたしは、version 3.3.3を使っています。
     3.4は未確認です。うまくいかないときは教えてください。

     makeは、BSDでもGNUでも使えます。

コンパイルはいつものように。

  $ ./configure
  $ make

6. インストール

いまのところ、インストールできるものはありません。


7. デモンストレーション

最低限の動作を確認できるように、小さなデモをつくりました。
FFT(高速フーリエ変換)を実行するプログラムです。

   サンプル 1

    $./demo 1 -1 1 -1 1 -1 1 -1
    s[0]=01000000_00000000_00000000_00000000 1
    s[1]=11000000_00000000_00000000_00000000 -1
    s[2]=01000000_00000000_00000000_00000000 1
    s[3]=11000000_00000000_00000000_00000000 -1
    s[4]=01000000_00000000_00000000_00000000 1
    s[5]=11000000_00000000_00000000_00000000 -1
    s[6]=01000000_00000000_00000000_00000000 1
    s[7]=11000000_00000000_00000000_00000000 -1
    Applying Fourier Transform...done
    g[0]={Re=0,Im=0}
    g[1]={Re=0,Im=0}
    g[2]={Re=0,Im=0}
    g[3]={Re=0,Im=0}
    g[4]={Re=1,Im=0}
    g[5]={Re=0,Im=0}
    g[6]={Re=0,Im=0}
    g[7]={Re=0,Im=0}
    Applying Inverse Fourier Transform...done
    t[0]=01000000_00000000_00000000_00000000 1
    t[1]=11000000_00000000_00000000_00000000 -1
    t[2]=01000000_00000000_00000000_00000000 1
    t[3]=11000000_00000000_00000000_00000000 -1
    t[4]=01000000_00000000_00000000_00000000 1
    t[5]=11000000_00000000_00000000_00000000 -1
    t[6]=01000000_00000000_00000000_00000000 1
    t[7]=11000000_00000000_00000000_00000000 -1


   サンプル 2

    $ ./demo 1 1 1 1 -1 -1 -1 -1
    s[0]=01000000_00000000_00000000_00000000 1
    s[1]=01000000_00000000_00000000_00000000 1
    s[2]=01000000_00000000_00000000_00000000 1
    s[3]=01000000_00000000_00000000_00000000 1
    s[4]=11000000_00000000_00000000_00000000 -1
    s[5]=11000000_00000000_00000000_00000000 -1
    s[6]=11000000_00000000_00000000_00000000 -1
    s[7]=11000000_00000000_00000000_00000000 -1
    Applying Fourier Transform...done
    g[0]={Re=0,Im=0}
    g[1]={Re=0.250000001,Im=-0.603553392}
    g[2]={Re=0,Im=0}
    g[3]={Re=0.250000002,Im=-0.103553391}
    g[4]={Re=0,Im=0}
    g[5]={Re=0.25,Im=0.103553391}
    g[6]={Re=0,Im=0}
    g[7]={Re=0.249999996,Im=0.603553392}
    Applying Inverse Fourier Transform...done
    t[0]=00111111_11111111_11111111_11111111 0.999999999
    t[1]=01000000_00000000_00000000_00000000 1
    t[2]=01000000_00000000_00000000_00000010 1.000000004
    t[3]=01000000_00000000_00000000_00000100 1.000000007
    t[4]=11000000_00000000_00000000_00000001 -0.999999999
    t[5]=11000000_00000000_00000000_00000000 -1
    t[6]=10111111_11111111_11111111_11111110 -1.000000004
    t[7]=10111111_11111111_11111111_11111100 -1.000000007

結果をどう判断するか難しいところです。
sin/cos関数の精度も評価しないといけませんね。

8. リンク

ここに追加される情報を待っています。


9. 謝辞

URRをたいへん魅力的に紹介されている鎌田誠さんに深く感謝いたします。


10. 連絡先

うすいたかゆき
臼井崇行
takayuki at genesis.ne.jp

